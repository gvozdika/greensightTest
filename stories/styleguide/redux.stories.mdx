import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="Styleguide / Redux" />

# Redux

На проектах используется [Redux](https://redux.js.org/) для определения глобального стейта приложения, к которому можно иметь доступ на SSR. Для связи Redux стора с компонентами используется [React Redux](https://react-redux.js.org/). Для упрощения работы с Redux используется [Redux Toolkit](https://redux-toolkit.js.org/).

## Reducers

Редусеры лежат в директории `reducers` – они хранятся в отдельных файлах, и в `index.ts` объединяются в единый rootReducer. Файл редусера в простейшем случае содержит слайс и список селекторов. Например:

```ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '@reducers/index';

interface Example {
    someValue: string;
}

interface ExampleSlice {
    example: Example | null;
}

const exampleSlice = createSlice({
    name: 'example',
    initialState: { example: null } as ExampleSlice,
    reducers: {
        setExample: (state, action: PayloadAction<Example>) => {
            state.example = action.payload;
        },
    },
});

const { reducer, actions } = exampleSlice;
export const { setExample } = actions;

const example = (state: RootState) => state.example.example;

export const selectors = { example };

export default reducer;
```

### TS interfaces

Общие рекомендации:

1. Определять интерфейс слайса и использовать его в **initialState** через type assertion
1. Для синхронных экшенов определять типы пейлода наверху файла редусера и использовать их в редусере через **PayloadAction**
1. Для асинхронных экшенов определять типы в соответствующем файле `api`, взяв за основу Swagger, и импортировать их в файл редусера (см. `api/category.ts` в качестве примера)

### Slices

Редусер определяется через [createSlice](https://redux-toolkit.js.org/api/createSlice) - он обязательно содержит **name**, совпадающий с именем файла, и **initialState** с типом слайса. Через поле **reducers** определяются синхронные экшн криейторы, которые будут использоваться в приложении напрямую, асинхронные создаются через **extraReducers**. В отличие от классического Redux, Redux Toolkit использует внутри [immer](https://github.com/immerjs/immer), что позволяет использовать мутабельные операции.

Далее слайс можно деструктурировать, получив **reducer** для добавления в **rootReducer**, идущий дефолтным экспортом, и синхронные экшены из **reducers**, которые далее можно деструктурировать и экспортировать именованными экспортами.

### Selectors

Для доступа к частям стора используются селекторы, которые определяются в файле редусера.

Общие рекомендации:

1. Создавать селекторы для корневых частей слайса
1. Создавать селекторы для сложнополучаемых частей слайса, например требующие использования map/reduce
1. Не создавать селекторы для полей, которые можно получить простой деструктуризацией результата другого селектора
1. Использовать [createSelector](https://github.com/reduxjs/reselect#reselect) только когда появляется реальная проблема с оптимизацией

### Thunks

Асинхронные экшн криейторы, работающие с API, создаются отдельно от слайса через [createAsyncThunk](https://redux-toolkit.js.org/api/createAsyncThunk) - фанк определяется отдельно от слайса и экспортируется, что позволяет использовать его как синхронные экшены. В поле extraReducers слайса прописываются редусеры экшенов fulfilled/pending/rejected (см. `reducers/category.ts`).

## API

В директории `api` в `index.ts` лежит axios клиент с настройками под API, эндроинты разбиты по файлам.

Общие рекомендации:

1. Называть функции по имени метода, например `GET /cart/item` -> `getCartItem`
1. Функции держать простыми: делать запрос и возвращать response, дополнительно разве что подготавливать данные для отправки запроса
1. Не включать try/catch - его менеджмент на стороне редусеров
1. Возвращать весь response объект, а не только поле data
1. Определять интерфейсы ответов, взяв за основу Swagger
1. Для мокинга определять асинхронную функцию в том же файле, которую затем можно будет элементарно заменить на реальный запрос (см. `api/category.ts`)

## Store usage

Для использования данных стора и экшенов на уровне компонентов используются хуки [useSelector](https://react-redux.js.org/api/hooks#useselector) и [useDispatch](https://react-redux.js.org/api/hooks#usedispatch) (см. `pages/Example.tsx`).

Компоненты из директории `components` полностью статичные и не должны знать о сторе, иначе Storybook будет поломан. Для прокидывания данных стора в эти компоненты используйте хуки на уровне страниц или создавайте контейнеры.

Общие рекомендации:

1. В качестве аргумента **useSelector** используйте определённые в редусере селекторы
1. Используйте по одному селектору на каждый **useSelector** вместо использования целого объекта, как в **mapStateToProps**
1. Используйте деструктуризацию для парсинга результата селектора вместо создания дополнительных селекторов
1. Не используйте контейнеры, если того же результата можно достичь через вставку на страницу компонента и выделение логики в кастомный хук

## SSR

Чтобы иметь доступ к стору на серверном рендере store создаётся на сервере в `server/createStore.ts`. Для сохранения стейта на клиенте стейт вставляется в шаблон в виде скрипта, прописывающего `window.__INITIAL_STATE__`. Затем уже на клиенте в `client/index.ts` происходит новое создание стора, но уже с этим значением в качестве **initialState**. После этого скрипт удаляется из разметки.

Для работы со стором на SSR используется 3-хэтапное получение данных:

1. Общие данные для всех страниц получаются через диспатчи в начале `server/createStore.ts`
1. Специфичные для отдельных страниц данные получаются через функции **loadData** в `pages/index.ts`
1. Общие данные, требующие предварительной загрузки данных по страницам, получаются через диспатчи в конце `server/createStore.ts` (seo, например)

Общие рекомендации:

1. Прежде чем прописывать **loadData** подумайте не общие ли это данные, чтобы они не оказались только на части страниц
1. Определяйте **loadData** строго в роутах, т.к. определение на страницах ломает code splitting
1. Возвращайте из **loadData** диспатч или массив диспатчей, нет необходимости в **Promise.all**
1. Помните, что у вас есть доступ к стору изнутри фанков вместо того чтобы делать **store.getState()** на уровне **loadData**
1. Используйте единые механизмы для парсинга URL, например предусмотренный хелпер **getCodeFromUrl**
